#!/usr/bin/env perl
#
# KeyNanny provides a framework to protect sensitive data on a Unix host.
# keynanny implements a command line client for
# - setting values
# - getting values
# - listing available keys
# - rendering templates
#
# Copyright (c) 2014 The CertNanny Project
#
# Licensed under the Apache License, Version 2.0 and the GNU General Public License, Version 2.0.
# See the LICENSE file for details.
#


use strict;
use warnings;

use Getopt::Long;
use Template;

use Data::Dumper;
use KeyNanny::Protocol;

my %config;

sub usage {
    print "Usage: ...\n";
}

sub process_template {
    my $kn        = shift;
    my $infile    = shift;
    my $outfile   = shift;
    my $vars      = shift;

    my $fh;
    open( $fh, '<', $infile ) or die "Error opening template file: $!\n";
    my $input = do {
	local $/;
	<$fh>;
    };
    close $fh;

    my $template = Template->new( {} );

    if (! $template->process( \$input, $vars, $outfile )) {
	print STDERR "ERROR: Could not process template $infile: " . $template->error() . "\n";
	return;
    }

    return 1;
}

sub error_msg {
    my $result = shift;
    my $arg = shift;

    if (defined $arg) {
	print STDERR $arg . ' ';
    }
    return unless defined $result;
    return unless (ref $result eq 'HASH');
    return unless (defined $result->{STATUS});
    return 1 if ($result->{STATUS} eq 'OK');

    my $msg = '(' . $result->{STATUS};
    if (defined $result->{MESSAGE}) {
	$msg .= ': ' . $result->{MESSAGE};
    }
    $msg .= ')';

    print STDERR $msg . "\n";
    return 1;
}

my $socketfile;
my %defines;
my $outfile;
my $help;

GetOptions( 'socketfile=s' => \$socketfile,
	    'define=s'     => \%defines,
	    'outfile=s'    => \$outfile,
	    'help'         => \$help );

if ( $help ) {
    usage();
    exit 0;
}

###########################################################################
# process configuration file
if (! defined $socketfile) {
    die "No --socketfile specified. Stopped";
}

my $kn = KeyNanny::Protocol->new( { SOCKETFILE => $socketfile } ) or die "Error: $@";

my $cmd = shift;

if ( !defined $cmd ) {
    usage;
    exit 0;
}

my $rc = 0;
if ( $cmd eq 'get' ) {
    while (my $arg = shift) {
	my $result = $kn->get($arg);
	
	if ($result->{STATUS} eq 'OK') {
	    print $result->{DATA};
	} else {
	    error_msg($result, 'Could not get key');
	    $rc = 1;
	}
    }
} elsif ( $cmd eq 'set' ) {
    my $arg = shift;
    my $value = shift;

    if (! defined $value) {
	print STDERR "No value specified (use - for STDIN)\n";
	$rc = 1;
    } elsif ($value eq '-') {
	local $/;
	$value = <STDIN>;
    }
    if (defined $value) {
	my $result = $kn->set($arg, $value);
	if ($result->{STATUS} ne 'OK') {
	    error_msg($result, 'Could not set key');
	    $rc = 1;
	}
    }
} elsif ( $cmd eq 'list' ) {
    my $result = $kn->list();
    if ($result->{STATUS} eq 'OK') {
	print join("\n", @{$result->{KEYS}}) . "\n";
    } else {
	error_msg($result, "Could not get list of keys");
	$rc = 1;
    }
} elsif ( $cmd eq 'template' ) {
    my $infile = shift;

    if (! defined $outfile) {
	die "Missing --outfile option. Stopped";
    }

    my @variables;
    my $result = $kn->list();
    if ($result->{STATUS} eq 'OK') {
	@variables = @{$result->{KEYS}};
    } else {
	error_msg($result, "Could not get list of available entries from KeyNanny daemon");
	exit 1;
    }

    my %vars;
    foreach my $entry ( @variables ) {
	my $result = $kn->get($entry);
	if ($result->{STATUS} eq 'OK') {
	    $vars{$entry} = $result->{DATA};
	} else {
	    error_msg($result, "Could not get key $entry");
	    exit 1;
	}
    }
    # override values from keynanny by --defines on command line
    foreach my $entry (keys %defines) {
	$vars{$entry} = $defines{$entry};
    }

    if ( !process_template( $kn, $infile, $outfile, \%vars ) ) {
        $rc = 1;
    }
}
else {
    die "Invalid command '$cmd'. Stopped";
}

exit $rc;
